/*Íà âõîä ïðîãðàììå ïîäà¸òñÿ âçâåøåííûé íåîðèåíòèðîâàííûé ãðàô â âèäå ñïèñêà èíöèäåíòíîñòè.
Íà âûõîäå ïîëó÷àåì ñïèñîê èíöèäåíòíîñòè äëÿ ìèíèìàëüíîãî îñòîâíîãî äåðåâà.
Ãðàô íà âõîäå îáÿçàòåëüíî ñâÿçíûé(íî ýòî ìîæíî äîðàáîòàòü)
Äëÿ ïîñòðîåíèÿ îñòîâíîãî äåðåâà áûë èñïîëüçîâàí àëãîðèòì êðóñêàëëà â åãî íàèâíîé ðåàëèçàöèè*/

#include <stdio.h>
#include <stdlib.h>

struct edge
{
	int val1, val2, wei;
};

int main()
{
	int num_edges, num_vertixes, i, j, key, flag, min, *tree_id, mst_weight;
	char c = ';';
	struct edge * graph, *mst, temp;
	printf("Input the number of vertixes: \n");
	scanf("%d", &num_vertixes);
	num_edges = num_vertixes * num_vertixes;//ìàêñèìàëüíî âîçìîæíîå ÷èñëî ð¸áåð
	graph = (struct edge*)malloc(num_edges * sizeof(struct edge));
	i = -1;
	printf("Input the edges in a format: \nvertix1 vertix2 weight; \n...\nvertix1 vertix2 weight.\n");
	while (c != '.')
	{
		i++;
		scanf("%d %d %d", &graph[i].val1, &graph[i].val2, &graph[i].wei);
		c = getchar(); 
	} 
	num_edges = i; //÷èñëî ð¸áåð ôàêòè÷åñêîå
	for (i = 0; i <= num_edges; i++)
	{
		printf("<%d, %d> = %d; \n", graph[i].val1, graph[i].val2, graph[i].wei);
	}
	//ÿ çàäîëáàëàñü, ïîýòîìó ñîðòèðîâàòü áóäåì ïóçûðüêîì
	
	for (i = 0; i <= num_edges - 1; i++)
	{
		flag = 0; //ìàðêåð óïîðÿäî÷åííîñòè êîíöà ìàññèâà
		min = i;
		for (j = i; j < num_edges - i; j++)
		{
			if (graph[j].wei > graph[j + 1].wei)
			{
				temp = graph[j];
				graph[j] = graph[j + 1];
				graph[j + 1] = temp;
				flag = 1;
			}
			if (graph[j].wei < graph[min].wei)
			{
				min = j;
			}
		}
		if (flag == 0)
		{
			break;
		}
		if (min != i)
		{
			temp = graph[i];
			graph[i] = graph[min];
			graph[min] = temp;
		}
	}
	tree_id = (int*)malloc((num_vertixes+1)* sizeof(int)); //ìàññèâ, ñîäåðæàùèé ïðèíàäëåæíîñòü âåðøèí ê îäíîìó "ïîääåðåâó" â ïðîöåññå ïîñòðîåíèÿ MST
	for (i = 1; i <= num_vertixes; i++)
	{
		tree_id[i] = i;
	}

	mst = (struct edge*)malloc(num_edges * sizeof(struct edge));
	mst_weight = 0;
	int left, right, old_id, new_id;
	int k = 0;
	for (i = 0; i <= num_edges; i++)
	{
		left = graph[i].val1, right = graph[i].val2; 
		if (tree_id[left] != tree_id[right]) //åñëè êîíöû ðåáðà ïðèíàäëåæàò ðàçíûì "ïîääåðåâüÿì"
		{
			mst_weight += graph[i].wei;
			mst[k] = graph[i]; //òî ðåáðî èä¸ò â MST, à ïðèíàäëåæíîñòü "ïîääåðåâüÿì" ïåðåçàïèñâûàåòñÿ
			k++;
			if (tree_id[left] > tree_id[right]) //÷òîáû íå ïåðåíàçíà÷àòü îäíè è òå æå çíà÷åíèÿ, áóäåì ñâîäèòü âñ¸ ê íàèìåíüøåìó èç íîìåðîâ ïîääåðåâüåâ
			{
				old_id = tree_id[left];
				new_id = tree_id[right];
			}
			else 
			{
				old_id = tree_id[right];
				new_id = tree_id[left];
			}
			for (j = 1; j <= num_vertixes; j++)
			{
				if (tree_id[j] == old_id)
				{
					tree_id[j] = new_id;
				}
			}
		}
	}
	printf("Edges of MST with the weight of %d \n", mst_weight);
	for (i = 0; i < k; i++)
	{
		printf("<%d, %d> = %d;\n", mst[i].val1, mst[i].val2, mst[i].wei);
	}
	free(graph);
	free(mst);
	getchar();
	return 0;
}
